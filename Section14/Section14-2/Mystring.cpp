#include "Mystring.h"


Mystring::Mystring()
	:str{ new char[1] } {
	*str = '\0';
}

Mystring::Mystring(const char* s)
	: str{ nullptr } {
	if (s == nullptr) {
		str = new char[1];
		*str = '\0';
		/*if s is nullptr, make str pointer point to array size 1
		then derefernece str pointer and assign terminator '\0' */
	}
	else {
		str = new char[std::strlen(s) + 1];
		std::strcpy(str, s);
	}
}

//copy constructor
Mystring::Mystring(const Mystring& source)
//is there problem using initialz list like this? program seems to run fine
	:str{ new char[strlen(source.str) + 1] } {
	std::strcpy(str, source.str);
	/*std::cout << "copy constructor used" << std::endl;*/
}

//move constructor
Mystring::Mystring(Mystring&& source) noexcept
	: str{ source.str } {
	source.str = nullptr;
}
//move constructor, pass r-value reference to a Mystring 
//noexcept tells compiler this wont throw an exception
//rules of C++, if we provide move constructor or move assignment operator
//copy assignment  not generated by compiler

//when I didn't include, VS gave me Linker errors. 
//If it's protoyped in header, needs to be implemented in cpp
Mystring::~Mystring() {
	delete[] str;
};

void Mystring::display() const {
	std::cout << str << "length: " << get_length() << std::endl;
}

size_t Mystring::get_length() const {
	return std::strlen(str);
}

//return const pointer to cstyle string
const char* Mystring::get_str() const {
	return str;
}


//copy assignment
Mystring& Mystring::operator=(const Mystring& rhs) {
	//compare address if they are same\
	//return derefence pointer to Mystring if true
	if (this == &rhs) return *this;

	//otherwise clear whatever str pointer point at
	//allocate new mem, copy, dereference and return this pointer to Mystring object
	delete[]str;
	str = new char[std::strlen(rhs.str) + 1];
	std::strcpy(str, rhs.str);
	return *this;
}


//move assignment
Mystring& Mystring::operator=(Mystring&& rhs) noexcept {
	//always need to check for self assignment
	if (this == &rhs) return *this;

	delete[] str; //clear whatever str ptr point at
	str = rhs.str; //steal pointer
	rhs.str = nullptr; //null source ptr
	return *this; //return dereference pointer to Mystring object
}


std::ostream& operator<<(std::ostream& out, const Mystring& rhs) {
	out << rhs.str;
	return out;
}


std::istream& operator>>(std::istream& in, Mystring& rhs) {
	char* buff = new char[1000];
	in >> buff;
	rhs = Mystring{ buff };
	delete[]buff;
	return in;
}

Mystring operator-(const Mystring &obj){
	char* buff = new char[std::strlen(obj.str) + 1];
	std::strcpy(buff, obj.str);
	for (size_t i{ 0 }; i < std::strlen(buff); i++) {
		buff[i] = std::tolower(buff[i]);
	}
	Mystring temp{ buff };
	delete[] buff;
	return temp;
}

Mystring operator+(const Mystring& lhs, const Mystring& rhs) {
	char* buff = new char[std::strlen(lhs.str) + std::strlen(rhs.str) + 1];
	std::strcpy(buff, lhs.str);
	std::strcat(buff, rhs.str);
	Mystring temp{ buff };
	delete[] buff;
	return temp;
}

bool operator==(const Mystring& lhs, const Mystring& rhs) {
	return (std::strcmp(lhs.str, rhs.str) == 0);
}

bool operator!=(const Mystring& lhs, const Mystring& rhs) {
	return !(std::strcmp(lhs.str, rhs.str) == 0);
}

bool operator<(const Mystring& lhs, const Mystring& rhs) {
	return (std::strcmp(lhs.str, rhs.str) < 0);
}

bool operator>(const Mystring& lhs, const Mystring& rhs) {
	return (std::strcmp(lhs.str, rhs.str) > 0);
}


Mystring& operator+=(Mystring& lhs, const Mystring& rhs) {
	lhs = lhs + rhs;
	return lhs;
}

Mystring operator*(const Mystring &lhs, int num){
	char* buff = new char[std::strlen(lhs.str) * num + 1];
	std::strcpy(buff, lhs.str);
	for (size_t i{ 0 }; i < num - 1; i++) {
		std::strcat(buff, lhs.str);
	}
	Mystring temp{ buff };
	delete[]buff;
	return temp;
}

Mystring& operator*=(Mystring& lhs, int num) {
	lhs = lhs * num;
	return lhs;
}


Mystring& operator++(Mystring& obj) {
	char* buff = new char[std::strlen(obj.str) + 1];
	std::strcpy(buff, obj.str);
	for (size_t i{ 0 }; i < std::strlen(buff); i++) {
		buff[i] = std::toupper(buff[i]);
	}
	Mystring temp{ buff };
	delete[] buff;
	return temp;
}

Mystring operator++(Mystring& obj, int) {
	Mystring temp{ obj };
	++obj; //next time you call obj, it will be uppercase
	return temp; //returns still originalcase value
}

//note - not sure what I was missing, was getting linker error 2019.
//rewrote program and it went away. 
